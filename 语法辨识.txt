1.new()和newInstance区别
new：加载+实例化 强类型 高效  可以调用任何public构造函数
newInstance：实例化  弱类型 低效 只能调用无参构造 （显著优点是灵活）
class c = Class.forName("Example");
factory = (ExampleInterface)c.newInstance();上面代码已经不存在Example的类名称，它的优点是，无论Example类怎么变化，上述代码不变，甚至可以更换Example的兄弟类Example2 , Example3 , Example4……，只要他们继承ExampleInterface就可以。

2.String
1）
String s1 = "abc";  
String s2 = "abc";  
String s3 = new String("abc");  
System.out.println(s1 == s2);  //true
System.out.println(s1 == s3);  //false

像String s1 = "abc"; 这样申明的字符串对象，其值就是存储在常量池中。当我们创建String s1 = "abc"这样一个对象之后，"abc"就存储到了常量池（也可叫做字符串池）中，当我们创建引用String s2 = "abc" 的时候，Java底层会优先在常量池中查找是否存在"abc"，如果存在则让s2指向这个值，不会重新创建，如果常量池中没有则创建并添加的池中。

2）
关于String s = null，System.out.print(s);

String 对象：直接判断是否为 null，如果为 null 给 null 对象赋值为"null"。
非 String 对象：通过调用String.valueOf方法，如果是 null 对象，就返回"null"，否则调用对象的toString方法。

String s = null;s = s + "!";System.out.print(s);
编译器对字符串相加会进行优化，首先实例化一个StringBuilder，然后把相加的字符串按顺序append，最后调用toString返回一个String对象。append函数如果判断对象为 null，就会调用appendNull，填充"null"。

3.Integer
Integer a = 1000,b=1000;  
Integer c = 100,d=100;   
System.out.println(a==b); //false
System.out.println(c==d); //true

当我们声明一个Integer c = 100;的时候。此时会进行自动装箱操作，简单点说，也就是把基本数据类型转换成Integer对象，而转换成Integer对象正是调用的valueOf方法，可以看到，Integer中把-128-127 缓存了下来。官方解释是小的数字使用的频率比较高，所以为了优化性能，把这之间的数缓存了下来。这就是为什么这道题的答案回事false和ture了。当声明的Integer对象的值在-128-127之间的时候，引用的是同一个对象，所以结果是true。




4.final
 public void mRun(final String name){  
        new Runnable() {  
              
            public void run() {  
                            try {  
                              Thread.sleep(1000);  
                           } catch (InterruptedException e) {  
                             // TODO Auto-generated catch block  
                            e.printStackTrace();  
                           }    
                           System.out.println(name);  
            }  
        }.start();  
    }  

为什么要加final关键字。首先内部类的生命周期是成员级别的，而局部变量的生命周期实在方法体之类。也就是说会出现这样一种情况，当mRun方法执行，new 的线程运行，新线程里面会睡一秒。主线程会继续执行，mRun执行完毕，name属性生命周期结束。1秒之后，Syetem.out.printh(name)执行。然而此时name已经寿终正寝，不在内存中了。Java就是为了杜绝这种错误，严格要求内部类中方位局部变量，必须使用final关键字修饰。局部变量被final修饰之后，此时会在内存中保有一份局部变得的复制品，当内部类访问的时候其实访问的是这个复制品。

5.内部类静态属性（或静态块）会在内部类第一次被调用的时候按顺序被初始化（或执行）。